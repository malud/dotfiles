---
- name: Install Development Tools and Modern CLI Utilities
  hosts: localhost
  connection: local
  become: false

  vars:
    local_bin: "{{ ansible_facts['env']['HOME'] }}/.local/bin"
    local_share: "{{ ansible_facts['env']['HOME'] }}/.local/share"

  environment:
    DEBIAN_FRONTEND: noninteractive

  tasks:
    # Update package cache
    - name: Update package cache (apt)
      become: true
      apt:
        update_cache: yes
        cache_valid_time: 3600
      when: ansible_facts['pkg_mgr'] == "apt"

    # Install core utilities via package manager
    - name: Install core CLI tools (apt)
      become: true
      apt:
        name:
          - bat
          - fd-find
          - ripgrep
          - fzf
          - netcat-openbsd
          - nmap
          - iputils-ping
          - mtr-tiny
          - curl
          - wget
          - git
          - jq
          - unzip
          - tar
        state: present
      when: ansible_facts['pkg_mgr'] == "apt"

    - name: Install core CLI tools (dnf/yum)
      become: true
      package:
        name:
          - bat
          - fd-find
          - ripgrep
          - fzf
          - nmap-ncat
          - nmap
          - iputils
          - mtr
          - curl
          - wget
          - git
          - jq
          - unzip
          - tar
        state: present
      when: ansible_facts['pkg_mgr'] in ["dnf", "yum"]

    - name: Install core CLI tools (apk)
      become: true
      apk:
        name:
          - bat
          - fd
          - ripgrep
          - fzf
          - netcat-openbsd
          - nmap
          - iputils
          - mtr
          - curl
          - wget
          - git
          - jq
          - unzip
          - tar
        state: present
      when: ansible_facts['pkg_mgr'] == "apk"

    # Create symlinks for Debian-based bat/fd naming
    - name: Create ~/.local/bin directory
      file:
        path: "{{ local_bin }}"
        state: directory
        mode: '0755'

    - name: Create bat symlink (if batcat exists)
      file:
        src: /usr/bin/batcat
        dest: "{{ local_bin }}/bat"
        state: link
      when: ansible_facts['pkg_mgr'] == "apt"
      ignore_errors: yes

    - name: Create fd symlink (if fdfind exists)
      file:
        src: /usr/bin/fdfind
        dest: "{{ local_bin }}/fd"
        state: link
      when: ansible_facts['pkg_mgr'] == "apt"
      ignore_errors: yes

    # Install Neovim from official release
    - name: Check if Neovim is installed in ~/.local/bin
      stat:
        path: "{{ local_bin }}/nvim"
      register: nvim_check

    - name: Check if system Neovim exists
      command: which nvim
      register: system_nvim_check
      failed_when: false
      changed_when: false
      when: not nvim_check.stat.exists

    - name: Create symlink to system Neovim if present
      file:
        src: "{{ system_nvim_check.stdout }}"
        dest: "{{ local_bin }}/nvim"
        state: link
      when:
        - not nvim_check.stat.exists
        - system_nvim_check.rc == 0

    - name: Install Neovim from official release
      block:
        - name: Determine Neovim architecture
          set_fact:
            nvim_arch: "{{ 'arm64' if ansible_facts['architecture'] == 'aarch64' else 'x86_64' }}"

        - name: Create temporary directory for Neovim
          tempfile:
            state: directory
          register: nvim_temp

        - name: Download Neovim tarball
          get_url:
            url: "https://github.com/neovim/neovim/releases/latest/download/nvim-linux-{{ nvim_arch }}.tar.gz"
            dest: "{{ nvim_temp.path }}/nvim.tar.gz"
            mode: '0644'

        - name: Create Neovim installation directory
          file:
            path: "{{ local_share }}/nvim-linux-{{ nvim_arch }}"
            state: directory
            mode: '0755'

        - name: Extract Neovim
          unarchive:
            src: "{{ nvim_temp.path }}/nvim.tar.gz"
            dest: "{{ local_share }}"
            remote_src: yes

        - name: Create Neovim symlink
          file:
            src: "{{ local_share }}/nvim-linux-{{ nvim_arch }}/bin/nvim"
            dest: "{{ local_bin }}/nvim"
            state: link

        - name: Clean up temporary directory
          file:
            path: "{{ nvim_temp.path }}"
            state: absent

        - name: Setup Neovim plugins
          command: "{{ local_bin }}/nvim --headless '+Lazy! sync' '+TSUpdate' +qa"
          ignore_errors: yes
          changed_when: false
      when:
        - not nvim_check.stat.exists
        - system_nvim_check.rc != 0

    # Install gping
    - name: Check if gping is installed in ~/.local/bin
      stat:
        path: "{{ local_bin }}/gping"
      register: gping_check

    - name: Check if system gping exists
      command: which gping
      register: system_gping_check
      failed_when: false
      changed_when: false
      when: not gping_check.stat.exists

    - name: Create symlink to system gping if present
      file:
        src: "{{ system_gping_check.stdout }}"
        dest: "{{ local_bin }}/gping"
        state: link
      when:
        - not gping_check.stat.exists
        - system_gping_check.rc == 0

    - name: Install gping
      block:
        - name: Set gping architecture
          set_fact:
            gping_arch: "{{ 'arm64' if ansible_facts['architecture'] == 'aarch64' else 'x86_64' }}"

        - name: Create temporary directory for gping
          tempfile:
            state: directory
          register: gping_temp

        - name: Download gping
          get_url:
            url: "https://github.com/orf/gping/releases/download/gping-v1.20.1/gping-Linux-musl-{{ gping_arch }}.tar.gz"
            dest: "{{ gping_temp.path }}/gping.tar.gz"
            mode: '0644'

        - name: Extract gping
          unarchive:
            src: "{{ gping_temp.path }}/gping.tar.gz"
            dest: "{{ gping_temp.path }}"
            remote_src: yes

        - name: Install gping binary
          shell: |
            cd "{{ gping_temp.path }}"
            gping_binary=$(find . -name 'gping' -type f | head -n 1)
            if [ -n "$gping_binary" ]; then
              cp "$gping_binary" "{{ local_bin }}/gping"
              chmod 755 "{{ local_bin }}/gping"
            else
              echo "ERROR: gping binary not found in extracted archive"
              exit 1
            fi
          args:
            creates: "{{ local_bin }}/gping"

        - name: Clean up temporary directory
          file:
            path: "{{ gping_temp.path }}"
            state: absent

        - name: Display gping capabilities note
          debug:
            msg: "ℹ️  gping may require elevated privileges. If needed, run: sudo setcap cap_net_raw+ep $(which gping)"
      when:
        - not gping_check.stat.exists
        - system_gping_check.rc != 0

    # Install trippy
    - name: Check if trippy is installed in ~/.local/bin
      stat:
        path: "{{ local_bin }}/trip"
      register: trippy_check

    - name: Check if system trippy exists
      command: which trip
      register: system_trippy_check
      failed_when: false
      changed_when: false
      when: not trippy_check.stat.exists

    - name: Create symlink to system trippy if present
      file:
        src: "{{ system_trippy_check.stdout }}"
        dest: "{{ local_bin }}/trip"
        state: link
      when:
        - not trippy_check.stat.exists
        - system_trippy_check.rc == 0

    - name: Install trippy
      block:
        - name: Set trippy architecture
          set_fact:
            trippy_arch: "{{ 'aarch64' if ansible_facts['architecture'] == 'aarch64' else 'x86_64' }}"
            trippy_libc: "{{ 'musl' if ansible_facts['pkg_mgr'] == 'apk' else 'gnu' }}"

        - name: Create temporary directory for trippy
          tempfile:
            state: directory
          register: trippy_temp

        - name: Download trippy
          get_url:
            url: "https://github.com/fujiapple852/trippy/releases/download/0.13.0/trippy-0.13.0-{{ trippy_arch }}-unknown-linux-{{ trippy_libc }}.tar.gz"
            dest: "{{ trippy_temp.path }}/trippy.tar.gz"
            mode: '0644'

        - name: Extract trippy
          unarchive:
            src: "{{ trippy_temp.path }}/trippy.tar.gz"
            dest: "{{ trippy_temp.path }}"
            remote_src: yes

        - name: Install trippy binary
          shell: |
            cd "{{ trippy_temp.path }}"
            trip_binary=$(find . -name 'trip' -type f | head -n 1)
            if [ -n "$trip_binary" ]; then
              cp "$trip_binary" "{{ local_bin }}/trip"
              chmod 755 "{{ local_bin }}/trip"
            else
              echo "ERROR: trip binary not found in extracted archive"
              exit 1
            fi
          args:
            creates: "{{ local_bin }}/trip"

        - name: Clean up temporary directory
          file:
            path: "{{ trippy_temp.path }}"
            state: absent

        - name: Display trippy capabilities note
          debug:
            msg: "ℹ️  trippy may require elevated privileges. If needed, run: sudo setcap cap_net_raw+ep $(which trip)"
      when:
        - not trippy_check.stat.exists
        - system_trippy_check.rc != 0

    # Install eza (modern ls replacement)
    - name: Check if eza is installed in ~/.local/bin
      stat:
        path: "{{ local_bin }}/eza"
      register: eza_check

    - name: Check if system eza exists
      command: which eza
      register: system_eza_check
      failed_when: false
      changed_when: false
      when: not eza_check.stat.exists

    - name: Create symlink to system eza if present
      file:
        src: "{{ system_eza_check.stdout }}"
        dest: "{{ local_bin }}/eza"
        state: link
      when:
        - not eza_check.stat.exists
        - system_eza_check.rc == 0

    - name: Install eza
      block:
        - name: Set eza architecture and libc variant
          set_fact:
            eza_arch: "{{ 'aarch64' if ansible_facts['architecture'] == 'aarch64' else 'x86_64' }}"
            eza_libc: "{{ 'gnu' if ansible_facts['architecture'] == 'aarch64' else 'musl' }}"

        - name: Create temporary directory for eza
          tempfile:
            state: directory
          register: eza_temp

        - name: Download eza
          get_url:
            url: "https://github.com/eza-community/eza/releases/latest/download/eza_{{ eza_arch }}-unknown-linux-{{ eza_libc }}.tar.gz"
            dest: "{{ eza_temp.path }}/eza.tar.gz"
            mode: '0644'

        - name: Extract eza
          unarchive:
            src: "{{ eza_temp.path }}/eza.tar.gz"
            dest: "{{ eza_temp.path }}"
            remote_src: yes

        - name: Find and install eza binary
          shell: |
            cd "{{ eza_temp.path }}"
            eza_binary=$(find . -name 'eza' -type f | head -n 1)
            if [ -n "$eza_binary" ]; then
              cp "$eza_binary" "{{ local_bin }}/eza"
              chmod 755 "{{ local_bin }}/eza"
            else
              echo "ERROR: eza binary not found in extracted archive"
              exit 1
            fi
          args:
            creates: "{{ local_bin }}/eza"

        - name: Clean up temporary directory
          file:
            path: "{{ eza_temp.path }}"
            state: absent
      when:
        - not eza_check.stat.exists
        - system_eza_check.rc != 0

    # Install starship prompt
    - name: Check if starship is installed in ~/.local/bin
      stat:
        path: "{{ local_bin }}/starship"
      register: starship_check

    - name: Check if system starship exists
      command: which starship
      register: system_starship_check
      failed_when: false
      changed_when: false
      when: not starship_check.stat.exists

    - name: Create symlink to system starship if present
      file:
        src: "{{ system_starship_check.stdout }}"
        dest: "{{ local_bin }}/starship"
        state: link
      when:
        - not starship_check.stat.exists
        - system_starship_check.rc == 0

    - name: Install starship
      block:
        - name: Download and install starship
          shell: "curl -sS https://starship.rs/install.sh | sh -s -- --bin-dir={{ local_bin }} -y"
          args:
            creates: "{{ local_bin }}/starship"
      when:
        - not starship_check.stat.exists
        - system_starship_check.rc != 0

    # Install kubectl
    - name: Check if kubectl is installed in ~/.local/bin
      stat:
        path: "{{ local_bin }}/kubectl"
      register: kubectl_check

    - name: Check if system kubectl exists
      command: which kubectl
      register: system_kubectl_check
      failed_when: false
      changed_when: false
      when: not kubectl_check.stat.exists

    - name: Create symlink to system kubectl if present
      file:
        src: "{{ system_kubectl_check.stdout }}"
        dest: "{{ local_bin }}/kubectl"
        state: link
      when:
        - not kubectl_check.stat.exists
        - system_kubectl_check.rc == 0

    - name: Install kubectl
      block:
        - name: Set kubectl architecture
          set_fact:
            kubectl_arch: "{{ 'arm64' if ansible_facts['architecture'] == 'aarch64' else 'amd64' }}"

        - name: Get stable kubectl version
          uri:
            url: https://dl.k8s.io/release/stable.txt
            return_content: yes
            timeout: 120
          register: kubectl_version
          retries: 3
          delay: 5
          until: kubectl_version.status == 200

        - name: Download kubectl
          get_url:
            url: "https://dl.k8s.io/release/{{ kubectl_version.content | trim }}/bin/linux/{{ kubectl_arch }}/kubectl"
            dest: "{{ local_bin }}/kubectl"
            mode: '0755'
            timeout: 180
          register: kubectl_download
          retries: 3
          delay: 5
          until: kubectl_download is succeeded

        - name: Verify kubectl installation
          command: "{{ local_bin }}/kubectl version --client"
          changed_when: false
      when:
        - not kubectl_check.stat.exists
        - system_kubectl_check.rc != 0

    # Install krew (kubectl plugin manager)
    - name: Check if krew is installed
      command: "{{ local_bin }}/kubectl-krew"
      register: krew_check
      failed_when: false
      changed_when: false
      when: kubectl_check.stat.exists

    - name: Install krew
      block:
        - name: Create temporary directory for krew
          tempfile:
            state: directory
          register: krew_temp

        - name: Set krew architecture
          set_fact:
            krew_arch: "{{ 'arm64' if ansible_facts['architecture'] == 'aarch64' else 'amd64' }}"

        - name: Download krew installer
          get_url:
            url: "https://github.com/kubernetes-sigs/krew/releases/latest/download/krew-linux_{{ krew_arch }}.tar.gz"
            dest: "{{ krew_temp.path }}/krew.tar.gz"
            mode: '0644'
            timeout: 120
          register: krew_download
          retries: 3
          delay: 5
          until: krew_download is succeeded

        - name: Extract krew
          unarchive:
            src: "{{ krew_temp.path }}/krew.tar.gz"
            dest: "{{ krew_temp.path }}"
            remote_src: yes

        - name: Install krew
          shell: |
            cd "{{ krew_temp.path }}"
            KREW="{{ krew_temp.path }}/krew-linux_{{ krew_arch }}"
            "$KREW" install krew
          environment:
            KREW_ROOT: "{{ ansible_facts['env']['HOME'] }}/.krew"
          changed_when: true

        - name: Create symlink for krew in local bin
          file:
            src: "{{ ansible_facts['env']['HOME'] }}/.krew/bin/kubectl-krew"
            dest: "{{ local_bin }}/kubectl-krew"
            state: link

        - name: Clean up temporary directory
          file:
            path: "{{ krew_temp.path }}"
            state: absent
      when: kubectl_check.stat.exists and (krew_check.rc | default(1)) != 0

    # Install kustomize
    - name: Check if kustomize is installed in ~/.local/bin
      stat:
        path: "{{ local_bin }}/kustomize"
      register: kustomize_check

    - name: Check if system kustomize exists
      command: which kustomize
      register: system_kustomize_check
      failed_when: false
      changed_when: false
      when: not kustomize_check.stat.exists

    - name: Create symlink to system kustomize if present
      file:
        src: "{{ system_kustomize_check.stdout }}"
        dest: "{{ local_bin }}/kustomize"
        state: link
      when:
        - not kustomize_check.stat.exists
        - system_kustomize_check.rc == 0

    - name: Install kustomize
      block:
        - name: Create temporary directory for kustomize
          tempfile:
            state: directory
          register: kustomize_temp

        - name: Set kustomize architecture
          set_fact:
            kustomize_arch: "{{ 'arm64' if ansible_facts['architecture'] == 'aarch64' else 'amd64' }}"

        - name: Get latest kustomize version
          uri:
            url: https://api.github.com/repos/kubernetes-sigs/kustomize/releases/latest
            return_content: yes
            timeout: 120
          register: kustomize_release
          retries: 3
          delay: 5
          until: kustomize_release.status == 200

        - name: Set kustomize version
          set_fact:
            kustomize_version: "{{ (kustomize_release.content | from_json).tag_name | regex_replace('^kustomize/', '') }}"

        - name: Download kustomize
          get_url:
            url: "https://github.com/kubernetes-sigs/kustomize/releases/download/kustomize/{{ kustomize_version }}/kustomize_{{ kustomize_version }}_linux_{{ kustomize_arch }}.tar.gz"
            dest: "{{ kustomize_temp.path }}/kustomize.tar.gz"
            mode: '0644'
            timeout: 120
          register: kustomize_download
          retries: 3
          delay: 5
          until: kustomize_download is succeeded

        - name: Extract kustomize
          unarchive:
            src: "{{ kustomize_temp.path }}/kustomize.tar.gz"
            dest: "{{ kustomize_temp.path }}"
            remote_src: yes

        - name: Install kustomize binary
          shell: |
            cd "{{ kustomize_temp.path }}"
            kustomize_binary=$(find . -name 'kustomize' -type f | head -n 1)
            if [ -n "$kustomize_binary" ]; then
              cp "$kustomize_binary" "{{ local_bin }}/kustomize"
              chmod 755 "{{ local_bin }}/kustomize"
            else
              echo "ERROR: kustomize binary not found in extracted archive"
              exit 1
            fi
          args:
            creates: "{{ local_bin }}/kustomize"

        - name: Clean up temporary directory
          file:
            path: "{{ kustomize_temp.path }}"
            state: absent
      when:
        - not kustomize_check.stat.exists
        - system_kustomize_check.rc != 0

    # Install k9s
    - name: Check if k9s is installed in ~/.local/bin
      stat:
        path: "{{ local_bin }}/k9s"
      register: k9s_check

    - name: Check if system k9s exists
      command: which k9s
      register: system_k9s_check
      failed_when: false
      changed_when: false
      when: not k9s_check.stat.exists

    - name: Create symlink to system k9s if present
      file:
        src: "{{ system_k9s_check.stdout }}"
        dest: "{{ local_bin }}/k9s"
        state: link
      when:
        - not k9s_check.stat.exists
        - system_k9s_check.rc == 0

    - name: Install k9s
      block:
        - name: Create temporary directory for k9s
          tempfile:
            state: directory
          register: k9s_temp

        - name: Set k9s architecture
          set_fact:
            k9s_arch: "{{ 'arm64' if ansible_facts['architecture'] == 'aarch64' else 'amd64' }}"

        - name: Download k9s
          get_url:
            url: "https://github.com/derailed/k9s/releases/latest/download/k9s_Linux_{{ k9s_arch }}.tar.gz"
            dest: "{{ k9s_temp.path }}/k9s.tar.gz"
            mode: '0644'
            timeout: 120
          register: k9s_download
          retries: 3
          delay: 5
          until: k9s_download is succeeded

        - name: Extract k9s
          unarchive:
            src: "{{ k9s_temp.path }}/k9s.tar.gz"
            dest: "{{ k9s_temp.path }}"
            remote_src: yes

        - name: Install k9s binary
          shell: |
            cd "{{ k9s_temp.path }}"
            k9s_binary=$(find . -name 'k9s' -type f | head -n 1)
            if [ -n "$k9s_binary" ]; then
              cp "$k9s_binary" "{{ local_bin }}/k9s"
              chmod 755 "{{ local_bin }}/k9s"
            else
              echo "ERROR: k9s binary not found in extracted archive"
              exit 1
            fi
          args:
            creates: "{{ local_bin }}/k9s"

        - name: Clean up temporary directory
          file:
            path: "{{ k9s_temp.path }}"
            state: absent
      when:
        - not k9s_check.stat.exists
        - system_k9s_check.rc != 0

    # Install just (command runner)
    - name: Check if just is installed in ~/.local/bin
      stat:
        path: "{{ local_bin }}/just"
      register: just_check

    - name: Check if system just exists
      command: which just
      register: system_just_check
      failed_when: false
      changed_when: false
      when: not just_check.stat.exists

    - name: Create symlink to system just if present
      file:
        src: "{{ system_just_check.stdout }}"
        dest: "{{ local_bin }}/just"
        state: link
      when:
        - not just_check.stat.exists
        - system_just_check.rc == 0

    - name: Install just
      block:
        - name: Set just architecture
          set_fact:
            just_arch: "{{ 'aarch64' if ansible_facts['architecture'] == 'aarch64' else 'x86_64' }}"

        - name: Get latest just version
          uri:
            url: https://api.github.com/repos/casey/just/releases/latest
            return_content: yes
            timeout: 120
          register: just_release
          retries: 3
          delay: 5
          until: just_release.status == 200

        - name: Set just version
          set_fact:
            just_version: "{{ (just_release.content | from_json).tag_name }}"

        - name: Create temporary directory for just
          tempfile:
            state: directory
          register: just_temp

        - name: Download just
          get_url:
            url: "https://github.com/casey/just/releases/download/{{ just_version }}/just-{{ just_version }}-{{ just_arch }}-unknown-linux-musl.tar.gz"
            dest: "{{ just_temp.path }}/just.tar.gz"
            mode: '0644'

        - name: Extract just
          unarchive:
            src: "{{ just_temp.path }}/just.tar.gz"
            dest: "{{ just_temp.path }}"
            remote_src: yes

        - name: Install just binary
          copy:
            src: "{{ just_temp.path }}/just"
            dest: "{{ local_bin }}/just"
            mode: '0755'
            remote_src: yes

        - name: Clean up temporary directory
          file:
            path: "{{ just_temp.path }}"
            state: absent
      when:
        - not just_check.stat.exists
        - system_just_check.rc != 0

    # Install ali (load testing tool)
    - name: Check if ali is installed in ~/.local/bin
      stat:
        path: "{{ local_bin }}/ali"
      register: ali_check

    - name: Check if system ali exists
      command: which ali
      register: system_ali_check
      failed_when: false
      changed_when: false
      when: not ali_check.stat.exists

    - name: Create symlink to system ali if present
      file:
        src: "{{ system_ali_check.stdout }}"
        dest: "{{ local_bin }}/ali"
        state: link
      when:
        - not ali_check.stat.exists
        - system_ali_check.rc == 0

    - name: Install ali
      block:
        - name: Set ali architecture
          set_fact:
            ali_arch: "{{ 'arm64' if ansible_facts['architecture'] == 'aarch64' else 'amd64' }}"

        - name: Get latest ali version
          uri:
            url: https://api.github.com/repos/nakabonne/ali/releases/latest
            return_content: yes
            timeout: 120
          register: ali_release
          retries: 3
          delay: 5
          until: ali_release.status == 200

        - name: Set ali version
          set_fact:
            ali_version: "{{ (ali_release.content | from_json).tag_name | regex_replace('^v', '') }}"

        - name: Create temporary directory for ali
          tempfile:
            state: directory
          register: ali_temp

        - name: Download ali
          get_url:
            url: "https://github.com/nakabonne/ali/releases/download/v{{ ali_version }}/ali_{{ ali_version }}_linux_{{ ali_arch }}.tar.gz"
            dest: "{{ ali_temp.path }}/ali.tar.gz"
            mode: '0644'
            timeout: 120
          register: ali_download
          retries: 3
          delay: 5
          until: ali_download is succeeded

        - name: Extract ali
          unarchive:
            src: "{{ ali_temp.path }}/ali.tar.gz"
            dest: "{{ ali_temp.path }}"
            remote_src: yes

        - name: Install ali binary
          shell: |
            cd "{{ ali_temp.path }}"
            ali_binary=$(find . -name 'ali' -type f | head -n 1)
            if [ -n "$ali_binary" ]; then
              cp "$ali_binary" "{{ local_bin }}/ali"
              chmod 755 "{{ local_bin }}/ali"
            else
              echo "ERROR: ali binary not found in extracted archive"
              exit 1
            fi
          args:
            creates: "{{ local_bin }}/ali"

        - name: Clean up temporary directory
          file:
            path: "{{ ali_temp.path }}"
            state: absent
      when:
        - not ali_check.stat.exists
        - system_ali_check.rc != 0

    # Completion message
    - name: Display installation completion
      debug:
        msg: "✅ Installation complete! Tools installed to {{ local_bin }}"

